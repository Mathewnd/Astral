diff -ruN --no-dereference mlibc-3.0.0-rc1/sysdeps/astral/crt-x86_64/crt0.S mlibc/sysdeps/astral/crt-x86_64/crt0.S
--- mlibc-3.0.0-rc1/sysdeps/astral/crt-x86_64/crt0.S	1969-12-31 21:00:00.000000000 -0300
+++ mlibc/sysdeps/astral/crt-x86_64/crt0.S	2022-10-10 16:31:06.853132251 -0300
@@ -0,0 +1,7 @@
+
+.section .text
+.global _start
+_start:
+    mov $main, %rdi
+    call __mlibc_entry
+
diff -ruN --no-dereference mlibc-3.0.0-rc1/sysdeps/astral/generic/astral.cpp mlibc/sysdeps/astral/generic/astral.cpp
--- mlibc-3.0.0-rc1/sysdeps/astral/generic/astral.cpp	1969-12-31 21:00:00.000000000 -0300
+++ mlibc/sysdeps/astral/generic/astral.cpp	2022-10-10 16:31:06.853132251 -0300
@@ -0,0 +1,6 @@
+#include <astral/syscall.h>
+
+int arch_ctl(int func, void* arg){
+	long ret;
+	return syscall(SYSCALL_ARCH_CTL, &ret, func, (uint64_t)arg);
+}
diff -ruN --no-dereference mlibc-3.0.0-rc1/sysdeps/astral/generic/entry.cpp mlibc/sysdeps/astral/generic/entry.cpp
--- mlibc-3.0.0-rc1/sysdeps/astral/generic/entry.cpp	1969-12-31 21:00:00.000000000 -0300
+++ mlibc/sysdeps/astral/generic/entry.cpp	2022-10-10 16:31:06.853132251 -0300
@@ -0,0 +1,34 @@
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+
+// defined by the POSIX library
+void __mlibc_initLocale();
+
+extern "C" uintptr_t *__dlapi_entrystack();
+
+extern char **environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard {
+	LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard() {
+	__mlibc_initLocale();
+
+	// Parse the exec() stack.
+	mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+	mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv,
+			__mlibc_stack_data.envp);
+}
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])) {
+	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
+	exit(result);
+}
+
diff -ruN --no-dereference mlibc-3.0.0-rc1/sysdeps/astral/generic/generic.cpp mlibc/sysdeps/astral/generic/generic.cpp
--- mlibc-3.0.0-rc1/sysdeps/astral/generic/generic.cpp	1969-12-31 21:00:00.000000000 -0300
+++ mlibc/sysdeps/astral/generic/generic.cpp	2022-10-12 01:10:42.579853920 -0300
@@ -0,0 +1,294 @@
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <astral/syscall.h>
+#include <astral/archctl.h>
+#include <string.h>
+#include <asm/ioctls.h>
+
+#define STUB_ONLY { __ensure(!"STUB_ONLY function was called"); __builtin_unreachable(); }
+
+namespace mlibc {
+	
+	// stub
+
+	uid_t sys_getuid(){
+		return 0;
+	}
+
+	// stub
+
+	gid_t sys_getgid(){
+		return 0;
+	}
+
+	// stub
+
+	uid_t sys_geteuid(){
+		return 0;
+	}
+
+	// stub
+
+	gid_t sys_getegid(){
+		return 0;
+	}
+	
+	// stub
+	
+	pid_t sys_getppid(){
+		return 1;
+	}
+	
+	// stub
+
+	int sys_getpgid(pid_t pid, pid_t* pgid){
+		*pgid = 1;
+		return 0;
+	}
+
+	// stub
+	
+	int sys_setpgid(pid_t pid, pid_t pgid){
+		return ENOSYS;
+	}
+
+
+	int sys_clock_get(int clock, time_t *secs, long *nanos){
+		*secs = 0;
+		*nanos = 0;
+		return 0;
+	}
+	
+	// stub
+
+	int sys_sigaction(int, const struct sigaction *__restrict,
+                struct sigaction *__restrict){
+		return ENOSYS;
+	}
+
+	// stub
+
+	int sys_sigprocmask(int how, const sigset_t *__restrict set, sigset_t *__restrict retrieve){
+		return ENOSYS;
+	}
+	
+	// stub
+	
+	int sys_ttyname(int fd, char *buf, size_t size) {
+		return ENOSYS;
+	}
+
+	// stub
+
+	#define ASTRALHOSTNAME "astral"
+
+	int sys_gethostname(char *buffer, size_t bufsize){
+	
+		memcpy(buffer, ASTRALHOSTNAME, strlen(ASTRALHOSTNAME));
+	
+		return 0;
+
+	}
+	
+	// stub
+	
+	int sys_uname(struct utsname *buf){
+		
+		memcpy(buf->sysname, "Astral", 7);
+		memcpy(buf->nodename, ASTRALHOSTNAME, strlen(ASTRALHOSTNAME)+1);
+		memcpy(buf->version, "0.0.1", 6);
+		memcpy(buf->release, "Astral 0.0.1", 13);
+		memcpy(buf->machine, "x86_64", 7);
+		memcpy(buf->domainname, ASTRALHOSTNAME, strlen(ASTRALHOSTNAME)+1);
+		
+		return 0;
+
+	}
+	
+	int sys_mkdir(const char* path, mode_t mode){
+		long res;
+		return syscall(SYSCALL_MKDIR, &res, (uint64_t)path, mode);
+	}
+
+	int sys_pipe(int *fds, int flags){
+		long res;
+		int err = syscall(SYSCALL_PIPE2, &res, flags);
+		fds[0] = res & 0xFFFFFFFF;
+		fds[1] = (res >> 32) & 0xFFFFFFFF;
+		return err;
+	}
+
+	int sys_tcgetattr(int fd, struct termios *attr){
+		int res;
+		return sys_ioctl(fd, TCGETS, (void*)attr, &res);
+	}
+
+	int sys_tcsetattr(int fd, int act, const struct termios *attr){
+		int res;
+		return sys_ioctl(fd, TCSETS, (void*)attr, &res);
+	}
+
+	int sys_ioctl(int fd, unsigned long request, void *arg, int *result){
+		long res;
+		int ret = syscall(SYSCALL_IOCTL, &res, fd, request, (uint64_t)arg);
+		*result = res;
+		return ret;
+	}
+	
+
+	int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read){
+		
+		return syscall(SYSCALL_GETDIRENT, (long*)bytes_read, handle, (uint64_t)buffer, max_size);	
+		
+	}
+	
+
+	int sys_open_dir(const char *path, int *handle){
+		return sys_open(path, O_RDONLY | O_DIRECTORY, 0, handle);
+	}
+
+	pid_t sys_getpid(){
+		long ret;
+		syscall(SYSCALL_GETPID, &ret);
+		return ret;
+	}
+	
+	int sys_chdir(const char* path){
+		long ret;
+		return syscall(SYSCALL_CHDIR, &ret, (uint64_t)path);
+	}
+
+	int sys_fcntl(int fd, int request, va_list args, int *result){
+		long ret;
+		// all currently supported requests only have one arg
+
+		long arg = va_arg(args, uint64_t);
+
+		long err = syscall(SYSCALL_FCNTL, &ret, fd, request, arg);
+		*result = ret;
+		return err;
+	}
+
+	int sys_dup(int fd, int flags, int* newfd){
+		long ret;
+		long err = syscall(SYSCALL_DUP, &ret, fd);
+		*newfd = ret;
+		return err;
+	}
+
+	int sys_dup2(int fd, int flags, int newfd){
+		long ret;
+		return syscall(SYSCALL_DUP2, &ret, fd, newfd);
+	}
+
+	int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid){
+		long ret;
+		long err = syscall(SYSCALL_WAITPID, &ret, pid, (uint64_t)status, flags);
+		*ret_pid = ret;
+		return err;
+	}
+
+
+	int sys_execve(const char* name, char* const argv[], char* const envp[]){
+		long ret;
+		return syscall(SYSCALL_EXECVE, &ret, (uint64_t)name, (uint64_t)argv, (uint64_t)envp);
+	}
+	
+	int sys_fork(pid_t* child){
+		long ret;
+		long err = syscall(SYSCALL_FORK, &ret);
+		*child = (int)ret;
+		return err;
+	}
+	
+	void sys_libc_log(const char *message){
+		size_t len = strlen(message);
+		char str[len+1];
+		memcpy(str, message, len);
+		str[len] = '\n';
+		long ret;
+		sys_write(2, str, len+1, &ret);
+	}
+	
+	[[noreturn]] void sys_libc_panic(){
+		sys_libc_log("libc: panic");
+		sys_exit(1);
+	}
+
+
+	[[noreturn]] void sys_exit(int status){
+		syscall(SYSCALL_EXIT, NULL, status);
+		__builtin_unreachable();
+	}
+
+	int sys_tcb_set(void* pointer){
+		return arch_ctl(ARCH_CTL_FSBASE, pointer);
+	}
+	[[gnu::weak]] int sys_futex_tid(){
+		long ret;
+		syscall(SYSCALL_GETTID, &ret);
+		return ret;
+	}
+	int sys_futex_wait(int *pointer, int expected, const struct timespec *time) STUB_ONLY
+	int sys_futex_wake(int *pointer) STUB_ONLY
+	int sys_anon_allocate(size_t size, void **pointer){
+		return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, 0, 0, pointer);
+	}
+	int sys_anon_free(void* pointer, size_t size){
+		sys_libc_log("libc: sys_anon_free is not implemented");
+		return 0;
+	}
+	
+	int sys_open(const char* pathname, int flags, mode_t mode, int* fd){
+		long ret;
+		long err = syscall(SYSCALL_OPEN, &ret, (uint64_t)pathname, flags, mode);
+		*fd = (int)ret;
+		return err;
+	};
+	int sys_read(int fd, void* buff, size_t count, ssize_t *bytes_read){
+		return syscall(SYSCALL_READ, bytes_read, fd, (uint64_t)buff, count);
+	}
+	int sys_write(int fd, const void* buff, size_t count, ssize_t *bytes_written){
+		return syscall(SYSCALL_WRITE, bytes_written, fd, (uint64_t)buff, count);
+	}
+	int sys_seek(int fd, off_t offset, int whence, off_t *new_offset){
+		return syscall(SYSCALL_LSEEK, new_offset, fd, offset, whence);
+	}
+	
+	int sys_close(int fd){
+		long ret;
+		return syscall(SYSCALL_CLOSE, &ret, fd);
+	}
+
+
+	[[gnu::weak]] int sys_stat(fsfd_target fsfdt, int fd, const char* path, int flags, struct stat *statbuf){
+		long ret;
+		switch(fsfdt){
+			case fsfd_target::path:
+				return syscall(SYSCALL_STAT, &ret, (uint64_t)path, (uint64_t)statbuf);
+			case fsfd_target::fd:
+				return syscall(SYSCALL_FSTAT, &ret, fd, (uint64_t)statbuf);
+			case fsfd_target::fd_path:
+				return syscall(SYSCALL_FSTATAT, &ret, fd, (uint64_t)path, (uint64_t)statbuf, flags);
+			default:
+				mlibc::infoLogger() << "libc: stat: Unknown fsfd_target: " << (int)fsfdt << frg::endlog;
+				return ENOSYS;
+		}
+	}
+
+	int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void** window){	
+		long ret = syscall(SYSCALL_MMAP, (int64_t*)window, (uint64_t)hint, size, prot, flags, fd, offset);
+		return ret;
+	}
+
+	int sys_vm_unmap(void* pointer, size_t size) STUB_ONLY
+	
+	int sys_isatty(int fd){
+		long ret;
+		return syscall(SYSCALL_ISATTY, &ret, fd);
+	}
+
+} // namespace mlibc
+
diff -ruN --no-dereference mlibc-3.0.0-rc1/sysdeps/astral/include/astral/archctl.h mlibc/sysdeps/astral/include/astral/archctl.h
--- mlibc-3.0.0-rc1/sysdeps/astral/include/astral/archctl.h	1969-12-31 21:00:00.000000000 -0300
+++ mlibc/sysdeps/astral/include/astral/archctl.h	2022-10-10 16:31:06.853132251 -0300
@@ -0,0 +1,11 @@
+#ifndef _ASTRAL_SYSCALL_ARCHCTL_INCLUDE
+#define _ASTRAL_SYSCALL_ARCHCTL_INCLUDE
+
+#include <astral/syscall.h>
+
+#define ARCH_CTL_GSBASE 0
+#define ARCH_CTL_FSBASE 1
+
+int arch_ctl(int func, void* arg);
+
+#endif
diff -ruN --no-dereference mlibc-3.0.0-rc1/sysdeps/astral/include/astral/syscall.h mlibc/sysdeps/astral/include/astral/syscall.h
--- mlibc-3.0.0-rc1/sysdeps/astral/include/astral/syscall.h	1969-12-31 21:00:00.000000000 -0300
+++ mlibc/sysdeps/astral/include/astral/syscall.h	2022-10-11 20:31:06.006656102 -0300
@@ -0,0 +1,51 @@
+#ifndef _SYSCALL_H_INCLUDE
+#define _SYSCALL_H_INCLUDE
+
+#define SYSCALL_LIBC_LOG 0
+#define SYSCALL_MMAP 1
+#define SYSCALL_ARCH_CTL 2
+#define SYSCALL_GETTID 3
+#define SYSCALL_OPEN 4
+#define SYSCALL_READ 5
+#define SYSCALL_LSEEK 6
+#define SYSCALL_CLOSE 7
+#define SYSCALL_ISATTY 8
+#define SYSCALL_WRITE 9
+#define SYSCALL_STAT 10
+#define SYSCALL_FSTAT 11
+#define SYSCALL_FORK 12
+#define SYSCALL_EXECVE 13
+#define SYSCALL_WAITPID 14
+#define SYSCALL_EXIT 15
+#define SYSCALL_DUP 16
+#define SYSCALL_DUP2 17
+#define SYSCALL_FCNTL 18
+#define SYSCALL_GETPID 19
+#define SYSCALL_GETDIRENT 20
+#define SYSCALL_IOCTL 21
+#define SYSCALL_CHDIR 22
+#define SYSCALL_FSTATAT 23
+#define SYSCALL_PIPE2 24
+#define SYSCALL_MKDIR 25
+
+#include <stddef.h>
+#include <stdint.h>
+
+static long syscall(long func, long* ret, uint64_t p1 = 0, uint64_t p2 = 0, uint64_t p3 = 0, uint64_t p4 = 0, uint64_t p5 = 0, uint64_t p6 = 0){
+	
+	volatile long err;
+
+	register uint64_t r4 asm("r10") = p4;
+	register uint64_t r5 asm("r8") = p5;
+	register uint64_t r6 asm("r9") = p6;
+	
+	asm volatile("syscall"
+		: "=a"(*ret), "=d"(err)
+		: "a"(func), "D"(p1), "S"(p2), "d"(p3), "r"(r4),
+		"r"(r5), "r"(r6)
+		: "memory", "rcx", "r11");
+    return err;
+	
+}
+
+#endif
diff -ruN --no-dereference mlibc-3.0.0-rc1/sysdeps/astral/meson.build mlibc/sysdeps/astral/meson.build
--- mlibc-3.0.0-rc1/sysdeps/astral/meson.build	1969-12-31 21:00:00.000000000 -0300
+++ mlibc/sysdeps/astral/meson.build	2022-10-10 16:31:06.853132251 -0300
@@ -0,0 +1,63 @@
+
+rtdl_sources += files(
+	'generic/generic.cpp',
+        'generic/astral.cpp',
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+        'generic/astral.cpp',
+	'generic/generic.cpp',
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/auxv.h',
+                'include/abi-bits/suseconds_t.h',
+                'include/abi-bits/fsblkcnt_t.h',
+                'include/abi-bits/fsfilcnt_t.h',
+                'include/abi-bits/clockid_t.h',
+                'include/abi-bits/socklen_t.h',
+                'include/abi-bits/socket.h',
+                'include/abi-bits/statfs.h',
+                'include/abi-bits/inotify.h',
+                'include/abi-bits/poll.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/utsname.h',
+                'include/abi-bits/limits.h',
+		subdir: 'abi-bits'
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
+
