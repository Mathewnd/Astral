diff --git mlibc-clean/abis/linux/in.h mlibc-workdir/abis/linux/in.h
index bb5b6ef..bd2f740 100644
--- mlibc-clean/abis/linux/in.h
+++ mlibc-workdir/abis/linux/in.h
@@ -88,6 +88,9 @@ struct group_req {
 
 #define IPPORT_RESERVED 1024
 
+#define IP_MULTICAST_TTL 33
+#define IPV6_MULTICAST_HOPS 18
+
 #define IPPROTO_IP       0
 #define IPPROTO_HOPOPTS  0
 #define IPPROTO_ICMP     1
diff --git mlibc-clean/meson.build mlibc-workdir/meson.build
index 2261926..03b6260 100644
--- mlibc-clean/meson.build
+++ mlibc-workdir/meson.build
@@ -153,6 +153,10 @@ elif host_machine.system() == 'dripos'
 	rtdl_include_dirs += include_directories('sysdeps/dripos/include')
 	libc_include_dirs += include_directories('sysdeps/dripos/include')
 	subdir('sysdeps/dripos')
+elif host_machine.system() == 'astral'
+        rtdl_include_dirs += include_directories('sysdeps/astral/include')
+        libc_include_dirs += include_directories('sysdeps/astral/include')
+        subdir('sysdeps/astral')
 else
 	error('No sysdeps defined for OS: ' + host_machine.system())
 endif
diff --git mlibc-clean/options/ansi/generic/string-stubs.cpp mlibc-workdir/options/ansi/generic/string-stubs.cpp
index d03e342..8558b81 100644
--- mlibc-clean/options/ansi/generic/string-stubs.cpp
+++ mlibc-workdir/options/ansi/generic/string-stubs.cpp
@@ -402,7 +402,6 @@ char *strerror(int e) {
 	case ENOPROTOOPT: s = "Protocol not available (ENOPROTOOPT)"; break;
 	case ENOTEMPTY: s = "Directory not empty (ENOTEMPTY)"; break;
 	case ENOTRECOVERABLE: s = "Sate not recoverable (ENOTRECOVERABLE)"; break;
-	case ENOTSUP: s = "Operation not supported (ENOTSUP)"; break;
 	case ENOTTY: s = "Inappropriate ioctl for device (ENOTTY)"; break;
 	case EOVERFLOW: s = "Value too large for defined datatype (EOVERFLOW)"; break;
 #if EOPNOTSUPP != ENOTSUP
diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..e034881 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -1,9 +1,10 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
+#include <mlibc/debug.hpp>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	mlibc::infoLogger() << "libc: backtrace() is not implemented!\n" << frg::endlog;
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git mlibc-workdir/sysdeps/astral/crt-x86_64/crt0.S mlibc-workdir/sysdeps/astral/crt-x86_64/crt0.S
new file mode 100644
index 0000000..0a0a4a0
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/crt-x86_64/crt0.S
@@ -0,0 +1,7 @@
+
+.section .text
+.global _start
+_start:
+    mov $main, %rdi
+    call __mlibc_entry
+
diff --git mlibc-workdir/sysdeps/astral/generic/astral.cpp mlibc-workdir/sysdeps/astral/generic/astral.cpp
new file mode 100644
index 0000000..7d5b1e3
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/generic/astral.cpp
@@ -0,0 +1,17 @@
+#include <astral/archctl.h>
+#include <errno.h>
+
+#define ARCH_CTL_GSBASE 0
+#define ARCH_CTL_FSBASE 1
+
+#ifndef MLIBC_BUILDING_RTDL
+
+int syscall_archctl(int func, void *arg) {
+	long ret;
+	long error = syscall(SYSCALL_ARCHCTL, &ret, func, (uint64_t)arg);
+	if (error)
+		errno = error;
+	return error ? -1 : ret;
+}
+
+#endif
diff --git mlibc-workdir/sysdeps/astral/generic/entry.cpp mlibc-workdir/sysdeps/astral/generic/entry.cpp
new file mode 100644
index 0000000..e5b087a
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/generic/entry.cpp
@@ -0,0 +1,33 @@
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+
+// defined by the POSIX library
+void __mlibc_initLocale();
+
+extern "C" uintptr_t *__dlapi_entrystack();
+
+extern char **environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard {
+	LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard() {
+	__mlibc_initLocale();
+
+	// Parse the exec() stack.
+	mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+	mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv,
+			__mlibc_stack_data.envp);
+}
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])) {
+	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
+	exit(result);
+}
+
diff --git mlibc-workdir/sysdeps/astral/generic/generic.cpp mlibc-workdir/sysdeps/astral/generic/generic.cpp
new file mode 100644
index 0000000..1bf8c55
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/generic/generic.cpp
@@ -0,0 +1,154 @@
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <astral/syscall.h>
+#include <astral/archctl.h>
+#include <string.h>
+#include <asm/ioctls.h>
+#include <stdlib.h>
+#include <poll.h>
+#include <sys/select.h>
+
+namespace mlibc {
+	
+	// stub
+
+	int sys_setuid(uid_t id) {
+		return 0;
+	}
+
+	// stub
+
+	int sys_setgid(gid_t id) {
+		return 0;
+	}
+	
+	// stub
+
+	uid_t sys_getuid() {
+		return 0;
+	}
+
+	// stub
+
+	gid_t sys_getgid() {
+		return 0;
+	}
+
+	// stub
+
+	uid_t sys_geteuid() {
+		return 0;
+	}
+
+	// stub
+
+	gid_t sys_getegid() {
+		return 0;
+	}
+	
+	// stub
+	
+	pid_t sys_getppid() {
+		return 1;
+	}
+	
+	// stub
+
+	int sys_getpgid(pid_t pid, pid_t *pgid) {
+		*pgid = 1;
+		return 0;
+	}
+
+	void sys_libc_log(const char *message) {
+		long ret;
+		syscall(SYSCALL_PRINT, &ret, (uint64_t)message);
+	}
+	
+	[[noreturn]] void sys_libc_panic() {
+		sys_libc_log("mlibc: panic");
+		for (;;) ;
+	}
+
+	[[noreturn]] void sys_exit(int status) {
+		sys_libc_log("mlibc: program requested exit");
+		sys_libc_panic();
+		__builtin_unreachable();
+	}
+
+	int sys_tcb_set(void *pointer) {
+		long r;
+		return syscall(SYSCALL_ARCHCTL, &r, ARCH_CTL_FSBASE, (uint64_t)pointer);
+	}
+
+	int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
+		return ENOSYS;
+	}
+	int sys_futex_wake(int *pointer) {
+		return ENOSYS;
+	}
+	
+
+	int sys_anon_allocate(size_t size, void **pointer) {
+		size += 4096 - (size % 4096);
+		return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, 0, 0, pointer);
+	}
+	int sys_anon_free(void *pointer, size_t size) {
+		size += 4096 - (size % 4096);
+		return sys_vm_unmap(pointer, size);
+	}
+	
+	int sys_open(const char *pathname, int flags, mode_t mode, int *fd) {
+		long ret;
+		long err = syscall(SYSCALL_OPENAT, &ret, AT_FDCWD, (uint64_t)pathname, flags, mode);
+		if (err)
+			return err;
+		*fd = ret;
+		return 0;
+	};
+
+	int sys_read(int fd, void *buff, size_t count, ssize_t *bytes_read) {
+		long readc;
+		long error = syscall(SYSCALL_READ, &readc, fd, (uint64_t)buff, count);
+		*bytes_read = readc;
+		return error;
+	}
+
+	int sys_write(int fd, const void *buff, size_t count, ssize_t *bytes_written) {
+		return ENOSYS;
+	}
+
+	int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+		long ret = 0;
+		long error = syscall(SYSCALL_SEEK, &ret, fd, offset, whence);
+		*new_offset = ret;
+		return error;
+	}
+	
+	int sys_close(int fd) {
+		long r;
+		return syscall(SYSCALL_CLOSE, &r, fd);
+	}
+
+	int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) {
+		long ret;
+		long err = syscall(SYSCALL_MMAP, &ret, (uint64_t)hint, size, prot, flags, fd, offset);
+		*window = (void *)ret;
+		return err;
+	}
+
+	int sys_vm_unmap(void *pointer, size_t size) {
+		return ENOSYS;
+	}
+	
+	int sys_isatty(int fd) {
+		return ENOSYS;
+	}
+
+	int sys_clock_get(int clock, time_t *secs, long *nanos) {
+		return ENOSYS;
+	}
+
+} // namespace mlibc
+
diff --git mlibc-workdir/sysdeps/astral/include/astral/archctl.h mlibc-workdir/sysdeps/astral/include/astral/archctl.h
new file mode 100644
index 0000000..990eca0
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/include/astral/archctl.h
@@ -0,0 +1,11 @@
+#ifndef _ASTRAL_SYSCALL_ARCHCTL_INCLUDE
+#define _ASTRAL_SYSCALL_ARCHCTL_INCLUDE
+
+#include <astral/syscall.h>
+
+#define ARCH_CTL_GSBASE 0
+#define ARCH_CTL_FSBASE 1
+
+int arch_ctl(int func, void *arg);
+
+#endif
diff --git mlibc-workdir/sysdeps/astral/include/astral/syscall.h mlibc-workdir/sysdeps/astral/include/astral/syscall.h
new file mode 100644
index 0000000..2d4b960
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/include/astral/syscall.h
@@ -0,0 +1,30 @@
+#ifndef _SYSCALL_H_INCLUDE
+#define _SYSCALL_H_INCLUDE
+
+#define SYSCALL_PRINT 0
+#define SYSCALL_MMAP 1
+#define SYSCALL_OPENAT 2
+#define SYSCALL_READ 3
+#define SYSCALL_SEEK 4
+#define SYSCALL_CLOSE 5
+#define SYSCALL_ARCHCTL 6
+
+#include <stddef.h>
+#include <stdint.h>
+
+static long syscall(long func, long* ret, uint64_t p1 = 0, uint64_t p2 = 0, uint64_t p3 = 0, uint64_t p4 = 0, uint64_t p5 = 0, uint64_t p6 = 0) {
+	volatile long err;
+
+	register uint64_t r4 asm("r10") = p4;
+	register uint64_t r5 asm("r8") = p5;
+	register uint64_t r6 asm("r9") = p6;
+
+	asm volatile("syscall"
+		: "=a"(*ret), "=d"(err)
+		: "a"(func), "D"(p1), "S"(p2), "d"(p3), "r"(r4),
+		"r"(r5), "r"(r6)
+		: "memory", "rcx", "r11");
+    return err;
+}
+
+#endif
diff --git mlibc-workdir/sysdeps/astral/meson.build mlibc-workdir/sysdeps/astral/meson.build
new file mode 100644
index 0000000..8a3f4d7
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/meson.build
@@ -0,0 +1,67 @@
+
+rtdl_sources += files(
+	'generic/generic.cpp',
+        'generic/astral.cpp',
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+        'generic/astral.cpp',
+	'generic/generic.cpp',
+	'threading/x86_64-thread.cpp',
+	'threading/x86_64-thread-entry.S',
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/auxv.h',
+                'include/abi-bits/suseconds_t.h',
+                'include/abi-bits/fsblkcnt_t.h',
+                'include/abi-bits/fsfilcnt_t.h',
+                'include/abi-bits/clockid_t.h',
+                'include/abi-bits/socklen_t.h',
+                'include/abi-bits/socket.h',
+                'include/abi-bits/statfs.h',
+                'include/abi-bits/inotify.h',
+                'include/abi-bits/poll.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/utsname.h',
+               'include/abi-bits/limits.h',
+               'include/abi-bits/shm.h',
+               'include/abi-bits/epoll.h',
+		'include/abi-bits/ioctls.h',
+		subdir: 'abi-bits'
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
diff --git mlibc-workdir/sysdeps/astral/threading/x86_64-thread-entry.S mlibc-workdir/sysdeps/astral/threading/x86_64-thread-entry.S
new file mode 100644
index 0000000..4cb3ae0
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/threading/x86_64-thread-entry.S
@@ -0,0 +1,7 @@
+ .section .text
+.global __mlibc_thread_entry
+__mlibc_thread_entry:
+	pop %rdi
+	pop %rsi
+	pop %rdx
+	call __mlibc_thread_trampoline
diff --git mlibc-workdir/sysdeps/astral/threading/x86_64-thread.cpp mlibc-workdir/sysdeps/astral/threading/x86_64-thread.cpp
new file mode 100644
index 0000000..c234e77
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/threading/x86_64-thread.cpp
@@ -0,0 +1,58 @@
+#include <sys/mman.h>
+#include <mlibc/debug.hpp>
+#include <errno.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <bits/ensure.h>
+#include <mlibc/tcb.hpp>
+
+
+extern "C" void __mlibc_thread_trampoline(void* (*fn)(void*), Tcb* tcb, void* arg){
+
+
+	if (mlibc::sys_tcb_set(tcb))
+		    __ensure(!"failed to set tcb for new thread");
+
+	while (__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED) == 0)
+		        mlibc::sys_futex_wait(&tcb->tid, 0, nullptr);	
+
+	tcb->returnValue = fn(arg);
+	
+	__atomic_store_n(&tcb->didExit, 1, __ATOMIC_RELEASE);
+	mlibc::sys_futex_wake(&tcb->didExit);
+
+	mlibc::sys_thread_exit();
+}
+
+#define DEFAULT_STACK 0x400000
+
+namespace mlibc{
+	
+	int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stack_size, size_t *guard_size){
+		
+		// TODO guard
+
+		mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
+
+		*guard_size = 0;
+			
+		*stack_size = *stack_size ? *stack_size : DEFAULT_STACK;
+
+		if(!*stack){
+			*stack = mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) + *stack_size;
+			if(*stack == MAP_FAILED)
+				return errno;
+		}
+
+		void** stack_it = (void**)*stack;
+		
+		*--stack_it = arg;
+		*--stack_it = tcb;
+		*--stack_it = entry;
+		
+		*stack = (void*)stack_it;
+		
+		return 0;
+
+	}
+	
+}
