diff --git mlibc-clean/abis/linux/in.h mlibc-workdir/abis/linux/in.h
index bb5b6ef..bd2f740 100644
--- mlibc-clean/abis/linux/in.h
+++ mlibc-workdir/abis/linux/in.h
@@ -88,6 +88,9 @@ struct group_req {
 
 #define IPPORT_RESERVED 1024
 
+#define IP_MULTICAST_TTL 33
+#define IPV6_MULTICAST_HOPS 18
+
 #define IPPROTO_IP       0
 #define IPPROTO_HOPOPTS  0
 #define IPPROTO_ICMP     1
diff --git mlibc-clean/meson.build mlibc-workdir/meson.build
index 2261926..03b6260 100644
--- mlibc-clean/meson.build
+++ mlibc-workdir/meson.build
@@ -153,6 +153,10 @@ elif host_machine.system() == 'dripos'
 	rtdl_include_dirs += include_directories('sysdeps/dripos/include')
 	libc_include_dirs += include_directories('sysdeps/dripos/include')
 	subdir('sysdeps/dripos')
+elif host_machine.system() == 'astral'
+        rtdl_include_dirs += include_directories('sysdeps/astral/include')
+        libc_include_dirs += include_directories('sysdeps/astral/include')
+        subdir('sysdeps/astral')
 else
 	error('No sysdeps defined for OS: ' + host_machine.system())
 endif
diff --git mlibc-clean/options/ansi/generic/string-stubs.cpp mlibc-workdir/options/ansi/generic/string-stubs.cpp
index d03e342..8558b81 100644
--- mlibc-clean/options/ansi/generic/string-stubs.cpp
+++ mlibc-workdir/options/ansi/generic/string-stubs.cpp
@@ -402,7 +402,6 @@ char *strerror(int e) {
 	case ENOPROTOOPT: s = "Protocol not available (ENOPROTOOPT)"; break;
 	case ENOTEMPTY: s = "Directory not empty (ENOTEMPTY)"; break;
 	case ENOTRECOVERABLE: s = "Sate not recoverable (ENOTRECOVERABLE)"; break;
-	case ENOTSUP: s = "Operation not supported (ENOTSUP)"; break;
 	case ENOTTY: s = "Inappropriate ioctl for device (ENOTTY)"; break;
 	case EOVERFLOW: s = "Value too large for defined datatype (EOVERFLOW)"; break;
 #if EOPNOTSUPP != ENOTSUP
diff --git mlibc-clean/options/glibc/generic/execinfo.cpp mlibc-workdir/options/glibc/generic/execinfo.cpp
index 3474615..e034881 100644
--- mlibc-clean/options/glibc/generic/execinfo.cpp
+++ mlibc-workdir/options/glibc/generic/execinfo.cpp
@@ -1,9 +1,10 @@
 #include <execinfo.h>
 #include <bits/ensure.h>
+#include <mlibc/debug.hpp>
 
 int backtrace(void **, int) {
-	__ensure(!"Not implemented");
-	__builtin_unreachable();
+	mlibc::infoLogger() << "libc: backtrace() is not implemented!\n" << frg::endlog;
+	return 0;
 }
 
 char **backtrace_symbols(void *const *, int) {
diff --git mlibc-workdir/sysdeps/astral/crt-x86_64/crt0.S mlibc-workdir/sysdeps/astral/crt-x86_64/crt0.S
new file mode 100644
index 0000000..0a0a4a0
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/crt-x86_64/crt0.S
@@ -0,0 +1,7 @@
+
+.section .text
+.global _start
+_start:
+    mov $main, %rdi
+    call __mlibc_entry
+
diff --git mlibc-workdir/sysdeps/astral/generic/astral.cpp mlibc-workdir/sysdeps/astral/generic/astral.cpp
new file mode 100644
index 0000000..7d5b1e3
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/generic/astral.cpp
@@ -0,0 +1,17 @@
+#include <astral/archctl.h>
+#include <errno.h>
+
+#define ARCH_CTL_GSBASE 0
+#define ARCH_CTL_FSBASE 1
+
+#ifndef MLIBC_BUILDING_RTDL
+
+int syscall_archctl(int func, void *arg) {
+	long ret;
+	long error = syscall(SYSCALL_ARCHCTL, &ret, func, (uint64_t)arg);
+	if (error)
+		errno = error;
+	return error ? -1 : ret;
+}
+
+#endif
diff --git mlibc-workdir/sysdeps/astral/generic/entry.cpp mlibc-workdir/sysdeps/astral/generic/entry.cpp
new file mode 100644
index 0000000..e5b087a
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/generic/entry.cpp
@@ -0,0 +1,33 @@
+#include <stdint.h>
+#include <stdlib.h>
+#include <bits/ensure.h>
+#include <mlibc/elf/startup.h>
+
+// defined by the POSIX library
+void __mlibc_initLocale();
+
+extern "C" uintptr_t *__dlapi_entrystack();
+
+extern char **environ;
+static mlibc::exec_stack_data __mlibc_stack_data;
+
+struct LibraryGuard {
+	LibraryGuard();
+};
+
+static LibraryGuard guard;
+
+LibraryGuard::LibraryGuard() {
+	__mlibc_initLocale();
+
+	// Parse the exec() stack.
+	mlibc::parse_exec_stack(__dlapi_entrystack(), &__mlibc_stack_data);
+	mlibc::set_startup_data(__mlibc_stack_data.argc, __mlibc_stack_data.argv,
+			__mlibc_stack_data.envp);
+}
+
+extern "C" void __mlibc_entry(int (*main_fn)(int argc, char *argv[], char *env[])) {
+	auto result = main_fn(__mlibc_stack_data.argc, __mlibc_stack_data.argv, environ);
+	exit(result);
+}
+
diff --git mlibc-workdir/sysdeps/astral/generic/generic.cpp mlibc-workdir/sysdeps/astral/generic/generic.cpp
new file mode 100644
index 0000000..97b963a
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/generic/generic.cpp
@@ -0,0 +1,301 @@
+#include <bits/ensure.h>
+#include <mlibc/debug.hpp>
+#include <mlibc/all-sysdeps.hpp>
+#include <errno.h>
+#include <astral/syscall.h>
+#include <astral/archctl.h>
+#include <string.h>
+#include <asm/ioctls.h>
+#include <stdlib.h>
+#include <poll.h>
+#include <sys/select.h>
+
+namespace mlibc {
+	
+	int sys_setuid(uid_t id) {
+		// TODO UNSTUB
+		return 0;
+	}
+
+	int sys_setgid(gid_t id) {
+		// TODO UNSTUB
+		return 0;
+	}
+
+	uid_t sys_getuid() {
+		// TODO UNSTUB
+		return 0;
+	}
+
+	gid_t sys_getgid() {
+		// TODO UNSTUB
+		return 0;
+	}
+
+	uid_t sys_geteuid() {
+		// TODO UNSTUB
+		return 0;
+	}
+
+	gid_t sys_getegid() {
+		// TODO UNSTUB
+		return 0;
+	}
+	
+	pid_t sys_getppid() {
+		// TODO UNSTUB
+		return 1;
+	}
+
+	int sys_getpgid(pid_t pid, pid_t *pgid) {
+		// TODO UNSTUB
+		*pgid = 1;
+		return 0;
+	}
+
+	#define ASTRALHOSTNAME "astral"
+
+	int sys_gethostname(char *buffer, size_t bufsize) {
+		// TODO unstub
+		memcpy(buffer, ASTRALHOSTNAME, strlen(ASTRALHOSTNAME));
+		return 0;
+	}
+
+	int sys_uname(struct utsname *buf) {
+		// TODO unstub
+		memcpy(buf->sysname, "Astral", 7);
+		memcpy(buf->nodename, ASTRALHOSTNAME, strlen(ASTRALHOSTNAME)+1);
+		memcpy(buf->version, "rw-0.0.1", 9);
+		memcpy(buf->release, "Astral", 13);
+		memcpy(buf->machine, "x86_64", 7);
+		memcpy(buf->domainname, ASTRALHOSTNAME, strlen(ASTRALHOSTNAME)+1);
+		return 0;
+	}
+
+	int sys_mkdirat(int dirfd, const char *path, mode_t mode) {
+		long ret;
+		return syscall(SYSCALL_MKDIRAT, &ret, dirfd, (uint64_t)path, mode);
+	}
+
+	int sys_mkdir(const char *path, mode_t mode) {
+		return sys_mkdirat(AT_FDCWD, path, mode);
+	}
+
+	int sys_ioctl(int fd, unsigned long request, void *arg, int *result) {
+		long ret;
+		long err = syscall(SYSCALL_IOCTL, &ret, fd, request, (uint64_t)arg);
+		*result = ret;
+		return err;
+	}
+
+	int sys_unlinkat(int fd, const char *path, int flags) {
+		long ret;
+		return syscall(SYSCALL_UNLINKAT, &ret, fd, (uint64_t)path, flags);
+	}
+
+	int sys_faccessat(int dirfd, const char *pathname, int mode, int flags){
+		long ret;
+		return syscall(SYSCALL_FACCESSAT, &ret, dirfd, (uint64_t)pathname, mode, flags);
+	}
+
+	int sys_access(const char *path, int mode){
+		return sys_faccessat(AT_FDCWD, path, mode, 0);
+	}
+
+	int sys_pipe(int *fds, int flags) {
+		long ret = 0;
+		long err = syscall(SYSCALL_PIPE2, &ret, flags);
+		if (err)
+			return err;
+
+		fds[0] = ret & 0xffffffff;
+		fds[1] = (ret >> 32) & 0xffffffff;
+		return err;
+	}
+
+	int sys_chdir(const char *path) {
+		long ret;
+		return syscall(SYSCALL_CHDIR, &ret, (uint64_t)path);
+	}
+
+	int sys_fcntl(int fd, int request, va_list args, int *result) {
+		long arg = va_arg(args, uint64_t);
+		long ret;
+		long err = syscall(SYSCALL_FCNTL, &ret, fd, request, arg);
+		*result = ret;
+		return err;
+	}
+
+	int sys_dup(int fd, int flags, int *newfd) {
+		long ret;
+		long err = syscall(SYSCALL_DUP, &ret, fd);
+		*newfd = ret;
+		return err;
+	}
+
+	int sys_dup2(int fd, int flags, int newfd) {
+		long ret;
+		return syscall(SYSCALL_DUP2, &ret, fd, newfd);
+	}
+
+	int sys_read_entries(int handle, void *buffer, size_t max_size, size_t *bytes_read) {
+		long ret;
+		long err = syscall(SYSCALL_GETDENTS, &ret, handle, (uint64_t)buffer, max_size);
+		if (err)
+			return err;
+		*bytes_read = ret;
+		return err;
+	}
+
+	int sys_waitpid(pid_t pid, int *status, int flags, struct rusage *ru, pid_t *ret_pid) {
+		long ret;
+		long err = syscall(SYSCALL_WAITPID, &ret, pid, (uint64_t)status, flags);
+		*ret_pid = ret;
+		return err;
+	}
+
+	int sys_execve(const char *path, char *const argv[], char *const envp[]) {
+		long ret;
+		return syscall(SYSCALL_EXECVE, &ret, (uint64_t)path, (uint64_t)argv, (uint64_t)envp);
+	}
+
+	int sys_fork(pid_t *pid) {
+		long ret = 0;
+		long error = syscall(SYSCALL_FORK, &ret);
+		*pid = ret;
+		return error;
+	}
+
+	int sys_stat(fsfd_target fsfdt, int fd, const char *path, int flags, struct stat *statbuf) {
+		long ret;
+		switch (fsfdt) {
+			case fsfd_target::path:
+				return syscall(SYSCALL_FSTATAT, &ret, AT_FDCWD, (uint64_t)path, (uint64_t)statbuf, 0);
+			case fsfd_target::fd:
+				return syscall(SYSCALL_FSTAT, &ret, fd, (uint64_t)statbuf);
+			case fsfd_target::fd_path:
+				return syscall(SYSCALL_FSTATAT, &ret, fd, (uint64_t)path, (uint64_t)statbuf, flags);
+			default:
+				mlibc::infoLogger() << "mlibc: stat: Unknown fsfd_target: " << (int)fsfdt << frg::endlog;
+				return ENOSYS;
+		}
+	}
+
+	pid_t sys_getpid() {
+		long ret;
+		syscall(SYSCALL_GETPID, &ret);
+		return ret;
+	}
+
+	void sys_libc_log(const char *message) {
+		long ret;
+		syscall(SYSCALL_PRINT, &ret, (uint64_t)message);
+	}
+	
+	[[noreturn]] void sys_libc_panic() {
+		sys_libc_log("mlibc: panic");
+		sys_exit(1);
+	}
+
+	[[noreturn]] void sys_exit(int status) {
+		syscall(SYSCALL_EXIT, NULL, status);
+		__builtin_unreachable();
+	}
+
+	int sys_tcb_set(void *pointer) {
+		long r;
+		return syscall(SYSCALL_ARCHCTL, &r, ARCH_CTL_FSBASE, (uint64_t)pointer);
+	}
+
+	int sys_futex_wait(int *pointer, int expected, const struct timespec *time) {
+		mlibc::infoLogger() << "mlibc: futex wait is a stub" << frg::endlog;
+		// TODO UNSTUB
+		return ENOSYS;
+	}
+	int sys_futex_wake(int *pointer) {
+		mlibc::infoLogger() << "mlibc: futex wake is a stub" << frg::endlog;
+		// TODO UNSTUB
+		return ENOSYS;
+	}
+	
+
+	int sys_anon_allocate(size_t size, void **pointer) {
+		size += 4096 - (size % 4096);
+		return sys_vm_map(NULL, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, 0, 0, pointer);
+	}
+	int sys_anon_free(void *pointer, size_t size) {
+		size += 4096 - (size % 4096);
+		return sys_vm_unmap(pointer, size);
+	}
+	
+	int sys_openat(int dirfd, const char *path, int flags, mode_t mode, int *fd) {
+		long ret;
+		long err = syscall(SYSCALL_OPENAT, &ret, dirfd, (uint64_t)path, flags, mode);
+		if (err)
+			return err;
+		*fd = ret;
+		return 0;
+	}
+
+	int sys_open(const char *pathname, int flags, mode_t mode, int *fd) {
+		return sys_openat(AT_FDCWD, pathname, flags, mode, fd);
+	};
+
+	int sys_open_dir(const char *path, int *handle) {
+		return sys_open(path, O_DIRECTORY, 0, handle);
+	}
+
+	int sys_read(int fd, void *buff, size_t count, ssize_t *bytes_read) {
+		long readc;
+		long error = syscall(SYSCALL_READ, &readc, fd, (uint64_t)buff, count);
+		*bytes_read = readc;
+		return error;
+	}
+
+	int sys_write(int fd, const void *buff, size_t count, ssize_t *bytes_written) {
+		long writec;
+		long error = syscall(SYSCALL_WRITE, &writec, fd, (uint64_t)buff, count);
+		*bytes_written = writec;
+		return error;
+	}
+
+	int sys_seek(int fd, off_t offset, int whence, off_t *new_offset) {
+		long ret = 0;
+		long error = syscall(SYSCALL_SEEK, &ret, fd, offset, whence);
+		*new_offset = ret;
+		return error;
+	}
+	
+	int sys_close(int fd) {
+		long r;
+		return syscall(SYSCALL_CLOSE, &r, fd);
+	}
+
+	int sys_vm_map(void *hint, size_t size, int prot, int flags, int fd, off_t offset, void **window) {
+		long ret;
+		long err = syscall(SYSCALL_MMAP, &ret, (uint64_t)hint, size, prot, flags, fd, offset);
+		*window = (void *)ret;
+		return err;
+	}
+
+	int sys_vm_unmap(void *pointer, size_t size) {
+		long ret;
+		return syscall(SYSCALL_MUNMAP, &ret, (uintptr_t)pointer, size);
+	}
+	
+	int sys_isatty(int fd) {
+		long ret;
+		return syscall(SYSCALL_ISATTY, &ret, fd);
+	}
+
+	int sys_clock_get(int clock, time_t *secs, long *nanos) {
+		struct timespec ts;
+		long ret;
+		int err = syscall(SYSCALL_CLOCKGET, &ret, clock, (uint64_t)&ts);
+		*secs = ts.tv_sec;
+		*nanos = ts.tv_nsec;
+		return err;
+	}
+
+} // namespace mlibc
+
diff --git mlibc-workdir/sysdeps/astral/include/astral/archctl.h mlibc-workdir/sysdeps/astral/include/astral/archctl.h
new file mode 100644
index 0000000..990eca0
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/include/astral/archctl.h
@@ -0,0 +1,11 @@
+#ifndef _ASTRAL_SYSCALL_ARCHCTL_INCLUDE
+#define _ASTRAL_SYSCALL_ARCHCTL_INCLUDE
+
+#include <astral/syscall.h>
+
+#define ARCH_CTL_GSBASE 0
+#define ARCH_CTL_FSBASE 1
+
+int arch_ctl(int func, void *arg);
+
+#endif
diff --git mlibc-workdir/sysdeps/astral/include/astral/syscall.h mlibc-workdir/sysdeps/astral/include/astral/syscall.h
new file mode 100644
index 0000000..96da753
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/include/astral/syscall.h
@@ -0,0 +1,52 @@
+#ifndef _SYSCALL_H_INCLUDE
+#define _SYSCALL_H_INCLUDE
+
+#define SYSCALL_PRINT 0
+#define SYSCALL_MMAP 1
+#define SYSCALL_OPENAT 2
+#define SYSCALL_READ 3
+#define SYSCALL_SEEK 4
+#define SYSCALL_CLOSE 5
+#define SYSCALL_ARCHCTL 6
+#define SYSCALL_WRITE 7
+#define SYSCALL_GETPID 8
+#define SYSCALL_FSTAT 9
+#define SYSCALL_FSTATAT 10
+#define SYSCALL_FORK 11
+#define SYSCALL_EXECVE 12
+#define SYSCALL_EXIT 13
+#define SYSCALL_WAITPID 14
+#define SYSCALL_MUNMAP 15
+#define SYSCALL_GETDENTS 16
+#define SYSCALL_DUP 17
+#define SYSCALL_DUP2 18
+#define SYSCALL_DUP3 19
+#define SYSCALL_FCNTL 20
+#define SYSCALL_CHDIR 21
+#define SYSCALL_PIPE2 22
+#define SYSCALL_ISATTY 23
+#define SYSCALL_FACCESSAT 24
+#define SYSCALL_UNLINKAT 25
+#define SYSCALL_IOCTL 26
+#define SYSCALL_MKDIRAT 27
+#define SYSCALL_CLOCKGET 28
+
+#include <stddef.h>
+#include <stdint.h>
+
+static long syscall(long func, long* ret, uint64_t p1 = 0, uint64_t p2 = 0, uint64_t p3 = 0, uint64_t p4 = 0, uint64_t p5 = 0, uint64_t p6 = 0) {
+	volatile long err;
+
+	register uint64_t r4 asm("r10") = p4;
+	register uint64_t r5 asm("r8") = p5;
+	register uint64_t r6 asm("r9") = p6;
+
+	asm volatile("syscall"
+		: "=a"(*ret), "=d"(err)
+		: "a"(func), "D"(p1), "S"(p2), "d"(p3), "r"(r4),
+		"r"(r5), "r"(r6)
+		: "memory", "rcx", "r11");
+    return err;
+}
+
+#endif
diff --git mlibc-workdir/sysdeps/astral/meson.build mlibc-workdir/sysdeps/astral/meson.build
new file mode 100644
index 0000000..8a3f4d7
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/meson.build
@@ -0,0 +1,67 @@
+
+rtdl_sources += files(
+	'generic/generic.cpp',
+        'generic/astral.cpp',
+)
+
+libc_sources += files(
+	'generic/entry.cpp',
+        'generic/astral.cpp',
+	'generic/generic.cpp',
+	'threading/x86_64-thread.cpp',
+	'threading/x86_64-thread-entry.S',
+)
+
+if not no_headers
+	install_headers(
+		'include/abi-bits/auxv.h',
+                'include/abi-bits/suseconds_t.h',
+                'include/abi-bits/fsblkcnt_t.h',
+                'include/abi-bits/fsfilcnt_t.h',
+                'include/abi-bits/clockid_t.h',
+                'include/abi-bits/socklen_t.h',
+                'include/abi-bits/socket.h',
+                'include/abi-bits/statfs.h',
+                'include/abi-bits/inotify.h',
+                'include/abi-bits/poll.h',
+		'include/abi-bits/seek-whence.h',
+		'include/abi-bits/vm-flags.h',
+		'include/abi-bits/errno.h',
+		'include/abi-bits/fcntl.h',
+		'include/abi-bits/in.h',
+		'include/abi-bits/resource.h',
+		'include/abi-bits/stat.h',
+		'include/abi-bits/signal.h',
+		'include/abi-bits/socket.h',
+		'include/abi-bits/termios.h',
+		'include/abi-bits/time.h',
+		'include/abi-bits/blkcnt_t.h',
+		'include/abi-bits/blksize_t.h',
+		'include/abi-bits/dev_t.h',
+		'include/abi-bits/gid_t.h',
+		'include/abi-bits/ino_t.h',
+		'include/abi-bits/mode_t.h',
+		'include/abi-bits/nlink_t.h',
+		'include/abi-bits/pid_t.h',
+		'include/abi-bits/uid_t.h',
+		'include/abi-bits/access.h',
+		'include/abi-bits/wait.h',
+		'include/abi-bits/utsname.h',
+               'include/abi-bits/limits.h',
+               'include/abi-bits/shm.h',
+               'include/abi-bits/epoll.h',
+		'include/abi-bits/ioctls.h',
+		subdir: 'abi-bits'
+	)
+endif
+
+if not headers_only
+	crt = custom_target('crt0',
+		build_by_default: true,
+		command: c_compiler.cmd_array() + ['-c', '-o', '@OUTPUT@', '@INPUT@'],
+		input: 'crt-x86_64/crt0.S',
+		output: 'crt0.o',
+		install: true,
+		install_dir: get_option('libdir')
+	)
+endif
diff --git mlibc-workdir/sysdeps/astral/threading/x86_64-thread-entry.S mlibc-workdir/sysdeps/astral/threading/x86_64-thread-entry.S
new file mode 100644
index 0000000..4cb3ae0
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/threading/x86_64-thread-entry.S
@@ -0,0 +1,7 @@
+ .section .text
+.global __mlibc_thread_entry
+__mlibc_thread_entry:
+	pop %rdi
+	pop %rsi
+	pop %rdx
+	call __mlibc_thread_trampoline
diff --git mlibc-workdir/sysdeps/astral/threading/x86_64-thread.cpp mlibc-workdir/sysdeps/astral/threading/x86_64-thread.cpp
new file mode 100644
index 0000000..c234e77
--- /dev/null
+++ mlibc-workdir/sysdeps/astral/threading/x86_64-thread.cpp
@@ -0,0 +1,58 @@
+#include <sys/mman.h>
+#include <mlibc/debug.hpp>
+#include <errno.h>
+#include <mlibc/all-sysdeps.hpp>
+#include <bits/ensure.h>
+#include <mlibc/tcb.hpp>
+
+
+extern "C" void __mlibc_thread_trampoline(void* (*fn)(void*), Tcb* tcb, void* arg){
+
+
+	if (mlibc::sys_tcb_set(tcb))
+		    __ensure(!"failed to set tcb for new thread");
+
+	while (__atomic_load_n(&tcb->tid, __ATOMIC_RELAXED) == 0)
+		        mlibc::sys_futex_wait(&tcb->tid, 0, nullptr);	
+
+	tcb->returnValue = fn(arg);
+	
+	__atomic_store_n(&tcb->didExit, 1, __ATOMIC_RELEASE);
+	mlibc::sys_futex_wake(&tcb->didExit);
+
+	mlibc::sys_thread_exit();
+}
+
+#define DEFAULT_STACK 0x400000
+
+namespace mlibc{
+	
+	int sys_prepare_stack(void **stack, void *entry, void *arg, void *tcb, size_t *stack_size, size_t *guard_size){
+		
+		// TODO guard
+
+		mlibc::infoLogger() << "mlibc: sys_prepare_stack() does not setup a guard!" << frg::endlog;
+
+		*guard_size = 0;
+			
+		*stack_size = *stack_size ? *stack_size : DEFAULT_STACK;
+
+		if(!*stack){
+			*stack = mmap(NULL, *stack_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0) + *stack_size;
+			if(*stack == MAP_FAILED)
+				return errno;
+		}
+
+		void** stack_it = (void**)*stack;
+		
+		*--stack_it = arg;
+		*--stack_it = tcb;
+		*--stack_it = entry;
+		
+		*stack = (void*)stack_it;
+		
+		return 0;
+
+	}
+	
+}
